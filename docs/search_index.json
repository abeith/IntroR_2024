[["basic-data-manipulation.html", "Chapter 3 Basic Data Manipulation Intended Learning Outcomes 3.1 Data Wrangling 3.2 Pre-Steps 3.3 select() 3.4 arrange() 3.5 filter() 3.6 mutate() 3.7 summarise() 3.8 Adding group_by() 3.9 The pipe operator (%&gt;%) 3.10 Pipe Practice with the Wickham Six", " Chapter 3 Basic Data Manipulation Intended Learning Outcomes Be able to use the following dplyr one-table verbs: select() arrange() filter() mutate() group_by() summarise() 3.1 Data Wrangling It is estimated that data scientists spend between 50-80% of their time cleaning and preparing data. This so-called data wrangling is a crucial first step in organising data for subsequent analysis (NYTimes., 2014). The goal is generally to get the data into a “tidy” format whereby each variable is a column, each observation is a row and each value is a cell. The tidyverse package, developed by Hadley Wickham, is a collection of R packages built around this basic concept and intended to make data science fast, easy and fun. It contains six core packages: dplyr, tidyr, readr, purrr, ggplot2, and tibble. dplyr provides a useful selection of functions - each corresponding to a basic verb: dplyr function description select() Include or exclude certain variables (columns) arrange() Reorder observations (rows) filter() Include or exclude certain observations (rows) mutate() Create new variables (columns) and preserve existing ones group_by() Organise observations (rows) by variables (columns) summarise() Compute summary statistics for selected variables (columns) These are termed one table verbs as they only operate on one table at a time. Today we will examine the Wickham Six; select(), arrange(), filter(), mutate(), group_by(), and summarise(). 3.2 Pre-Steps Before we dive in, let’s do some quick preparation. 3.2.1 Downloading materials Download the L3_manip.Rmd file from Teams and move it to your project folder (if you haven’t already!). 3.2.2 Loading in the required packages into the library As we will be using functions that are part of tidyverse, we need to load it into the library. You will also need to load in the new package babynames. You will need to have this package installed first before you can load it into the library, if you haven’t done that yet use the install.packages() function down in your console first. library(tidyverse) library(babynames) 3.2.3 Read in the data Now, today we will work with two different datasets, one fairly simple dataset, and another more messy complex dataset later one. The first is a large dataset about babynames (big surprise!). The package you installed and loaded into the library is infact a readymade dataset, that can be read straight into the Global Environment. We will deal with the second dataset later. Name_Data &lt;- babynames 3.2.4 View the data Click on Name_Data in your Global Environment to open your data in a new tab on the Source pane or call the object in your Console (by typing the name of the object Name_Data) to check that the data was correctly imported into R. Name_Data ## # A tibble: 1,924,665 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 ## 2 1880 F Anna 2604 0.0267 ## 3 1880 F Emma 2003 0.0205 ## 4 1880 F Elizabeth 1939 0.0199 ## 5 1880 F Minnie 1746 0.0179 ## 6 1880 F Margaret 1578 0.0162 ## 7 1880 F Ida 1472 0.0151 ## 8 1880 F Alice 1414 0.0145 ## 9 1880 F Bertha 1320 0.0135 ## 10 1880 F Sarah 1288 0.0132 ## # ℹ 1,924,655 more rows You could also view the data by using the function View(). If you are more of a typer than a mouse-user you can type View(Name_Data) into your Console. This will open the data in a read-only, spreadsheet-like format in a new tab on the Source pane. Remember from last week, we can also use glimpse() to view the columns and their datatypes. glimpse(Name_Data) ## Rows: 1,924,665 ## Columns: 5 ## $ year &lt;dbl&gt; 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880,… ## $ sex &lt;chr&gt; &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, … ## $ name &lt;chr&gt; &quot;Mary&quot;, &quot;Anna&quot;, &quot;Emma&quot;, &quot;Elizabeth&quot;, &quot;Minnie&quot;, &quot;Margaret&quot;, &quot;Ida&quot;,… ## $ n &lt;int&gt; 7065, 2604, 2003, 1939, 1746, 1578, 1472, 1414, 1320, 1288, 1258,… ## $ prop &lt;dbl&gt; 0.07238359, 0.02667896, 0.02052149, 0.01986579, 0.01788843, 0.016… head() would be helpful in displaying only the first 6 rows of the dataset, but remember not to get “tricked” by the number of observations shown in the output. head(Name_Data) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 ## 2 1880 F Anna 2604 0.0267 ## 3 1880 F Emma 2003 0.0205 ## 4 1880 F Elizabeth 1939 0.0199 ## 5 1880 F Minnie 1746 0.0179 ## 6 1880 F Margaret 1578 0.0162 Question Time How many rows (or observations) does Name_Data have? How many columns (or variables) does Name_Data have? Take some time to familiarise yourself with the variables in your dataframe. 3.3 select() You may not want to include every single variable in your analysis. In order to include or exclude certain variables (columns), use the select() function. The first argument to this function is the object you want to select variables from (i.e. our tibble called Name_Data), and the subsequent arguments are the variables to keep. For example, if you wanted to keep all variables except from prop, you could type: select(Name_Data, year, sex, name, n) ## # A tibble: 1,924,665 × 4 ## year sex name n ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1880 F Mary 7065 ## 2 1880 F Anna 2604 ## 3 1880 F Emma 2003 ## 4 1880 F Elizabeth 1939 ## 5 1880 F Minnie 1746 ## 6 1880 F Margaret 1578 ## 7 1880 F Ida 1472 ## 8 1880 F Alice 1414 ## 9 1880 F Bertha 1320 ## 10 1880 F Sarah 1288 ## # ℹ 1,924,655 more rows That works fine when you have realtively few variables like this dataset, however this menthod can become very time consuming if you have a lot of varibales in your dataset. There are two ways on how we could have done this easier and faster: We could use the colon operator :. Similar to last week where we used the colon operator for numerical sequences, we can use it here for selecting a sequence of column names. Here, it reads as “take object student_HM, and select columns year, and every other column though to n”. select(Name_Data, year:n) ## # A tibble: 1,924,665 × 4 ## year sex name n ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1880 F Mary 7065 ## 2 1880 F Anna 2604 ## 3 1880 F Emma 2003 ## 4 1880 F Elizabeth 1939 ## 5 1880 F Minnie 1746 ## 6 1880 F Margaret 1578 ## 7 1880 F Ida 1472 ## 8 1880 F Alice 1414 ## 9 1880 F Bertha 1320 ## 10 1880 F Sarah 1288 ## # ℹ 1,924,655 more rows We could use “negative selection”, i.e. select the variable we wanted to drop by adding a minus in front of it. select(Name_Data, -prop) ## # A tibble: 1,924,665 × 4 ## year sex name n ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1880 F Mary 7065 ## 2 1880 F Anna 2604 ## 3 1880 F Emma 2003 ## 4 1880 F Elizabeth 1939 ## 5 1880 F Minnie 1746 ## 6 1880 F Margaret 1578 ## 7 1880 F Ida 1472 ## 8 1880 F Alice 1414 ## 9 1880 F Bertha 1320 ## 10 1880 F Sarah 1288 ## # ℹ 1,924,655 more rows We also have the option of “de-selecting” more than one variable. By including the minus sign before each column we can remove as many as we want. select(Name_Data, -prop, -sex) ## # A tibble: 1,924,665 × 3 ## year name n ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 1880 Mary 7065 ## 2 1880 Anna 2604 ## 3 1880 Emma 2003 ## 4 1880 Elizabeth 1939 ## 5 1880 Minnie 1746 ## 6 1880 Margaret 1578 ## 7 1880 Ida 1472 ## 8 1880 Alice 1414 ## 9 1880 Bertha 1320 ## 10 1880 Sarah 1288 ## # ℹ 1,924,655 more rows Finally, we can change the order of our resulting columns by simply changing the order that we list them in. We could reverse the order of our first 3 columns like so: select(Name_Data, name, sex, year) ## # A tibble: 1,924,665 × 3 ## name sex year ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mary F 1880 ## 2 Anna F 1880 ## 3 Emma F 1880 ## 4 Elizabeth F 1880 ## 5 Minnie F 1880 ## 6 Margaret F 1880 ## 7 Ida F 1880 ## 8 Alice F 1880 ## 9 Bertha F 1880 ## 10 Sarah F 1880 ## # ℹ 1,924,655 more rows We can also use select() in combination with the c() function. Remember, c()is “hugging things together”. We would put a single minus in front of the c rather than each of the column. This will read as exclude every column listed within the brackets. select(Name_Data, -c(sex, n, prop)) Remember, if you don’t save this data to an object (e.g. the original dataframe Name_Data or under a new name), it won’t be saved. We have not saved any of the previous tasks to the Global Environment, so there should still be only one babynames related object, e.g. the tibble named Name_Data. Question Time Your turn Create a tibble called Name_Short that keeps all variables/columns from the data Name_Data except from sex and n. Your new object Name_Short should appear in your Global Environment. Solution # Jaimie&#39;s solution: Name_Short &lt;- select(Name_Data, -sex, -n) # OR Name_Short &lt;- select(Name_Data, -c(sex, n)) # OR Name_Short &lt;- select(Name_Data, year, name, prop) You could also reference the position of column, rather than the actual name. select(Name_Data,1,3,5) While it works code-wise, and seems a much quicker approach, it is a very bad idea in the name of reproducibility. If you send your code to a fellow researcher, they would have no idea what the code does. Moreover, if at some point, you need to add another column to your data, and/or decide to reorder the sequence of your columns, your code would not run anymore the way you expect it to. 3.3.1 Renaming Columns 3.3.1.1 Using select() One useful feature of the select() function is the ability to rename columns as you select them using the = operator. The structure of this works like so: select(data, new_column_name = old_column_name) To provide an example with our Name_Data variable, let’s say we want to keep only our year, name, and n columns, but we want the n column to instead be called count. We could achieve this in a single step like so: select(Name_Data, year, name, count = n) ## # A tibble: 1,924,665 × 3 ## year name count ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 1880 Mary 7065 ## 2 1880 Anna 2604 ## 3 1880 Emma 2003 ## 4 1880 Elizabeth 1939 ## 5 1880 Minnie 1746 ## 6 1880 Margaret 1578 ## 7 1880 Ida 1472 ## 8 1880 Alice 1414 ## 9 1880 Bertha 1320 ## 10 1880 Sarah 1288 ## # ℹ 1,924,655 more rows 3.3.1.2 Using rename() rename() is a nice alternative if we do not want to remove any columns. If you had 5 variables in a tibble, and wanted to change the name of one of them, your output would be 5 columns in total - one column with a changed name and 4 columns with the previous names. The rename() function follows the same renaming pattern as select(): rename(data, new_column_name = old_column_name) Let’s say we wanted to retain all columns in Name_Data, but change n to be called count and prop to be called proportion: rename(Name_Data, count = n, proportion = prop) ## # A tibble: 1,924,665 × 5 ## year sex name count proportion ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 ## 2 1880 F Anna 2604 0.0267 ## 3 1880 F Emma 2003 0.0205 ## 4 1880 F Elizabeth 1939 0.0199 ## 5 1880 F Minnie 1746 0.0179 ## 6 1880 F Margaret 1578 0.0162 ## 7 1880 F Ida 1472 0.0151 ## 8 1880 F Alice 1414 0.0145 ## 9 1880 F Bertha 1320 0.0135 ## 10 1880 F Sarah 1288 0.0132 ## # ℹ 1,924,655 more rows 3.4 arrange() The arrange() function can reorder observations (rows) in ascending (default) or descending order. The first argument to this function is again an object (in this case the tibble Name_Data), and the subsequent arguments are the variables (columns) you want to sort by. For example, if you wanted to sort by n in ascending order (which is the default in arrange()) you would type: Name_Arr &lt;- arrange(Name_Data, n) Name_Arr ## # A tibble: 1,924,665 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Adelle 5 0.0000512 ## 2 1880 F Adina 5 0.0000512 ## 3 1880 F Adrienne 5 0.0000512 ## 4 1880 F Albertine 5 0.0000512 ## 5 1880 F Alys 5 0.0000512 ## 6 1880 F Ana 5 0.0000512 ## 7 1880 F Araminta 5 0.0000512 ## 8 1880 F Arthur 5 0.0000512 ## 9 1880 F Birtha 5 0.0000512 ## 10 1880 F Bulah 5 0.0000512 ## # ℹ 1,924,655 more rows If you were to assign this code to the same object as before (i.e. Name_Data), the previous version of Name_Data would be overwritten. Notice how the n column is now organised in alphabetical order i.e. smallest number to largest. Suppose you wanted to reverse this order, displaying largest, you would need to wrap the name of the variable in the desc() function (i.e. for descending). Name_Arr2 &lt;- arrange(Name_Data, desc(n)) Name_Arr2 ## # A tibble: 1,924,665 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1947 F Linda 99686 0.0548 ## 2 1948 F Linda 96209 0.0552 ## 3 1947 M James 94756 0.0510 ## 4 1957 M Michael 92695 0.0424 ## 5 1947 M Robert 91642 0.0493 ## 6 1949 F Linda 91016 0.0518 ## 7 1956 M Michael 90620 0.0423 ## 8 1958 M Michael 90520 0.0420 ## 9 1948 M James 88588 0.0497 ## 10 1954 M Michael 88514 0.0428 ## # ℹ 1,924,655 more rows You can also sort by more than one column. For example, you could sort by name first, and then n second: Name_Arr3 &lt;- arrange(Name_Data, name, n) Name_Arr3 ## # A tibble: 1,924,665 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2007 M Aaban 5 0.00000226 ## 2 2009 M Aaban 6 0.00000283 ## 3 2010 M Aaban 9 0.00000439 ## 4 2016 M Aaban 9 0.00000446 ## 5 2011 M Aaban 11 0.00000542 ## 6 2012 M Aaban 11 0.00000543 ## 7 2017 M Aaban 11 0.0000056 ## 8 2013 M Aaban 14 0.00000694 ## 9 2015 M Aaban 15 0.00000736 ## 10 2014 M Aaban 16 0.00000783 ## # ℹ 1,924,655 more rows You can also arrange by multiple columns in descending order too, or arrange by one column in ascending order and another in descending order if you wanted. 3.5 filter() 3.5.1 Single criterion In order to include or exclude certain observations (rows), use the filter() function. The first argument to this function is an object (in this case the tibble Name_Data) and the subsequent argument is the criteria you wish to filter on. For example, if you want only those observations from the year of your birth: Name_MyYear &lt;- filter(Name_Data, year == 1988) head(Name_MyYear) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1988 F Jessica 51538 0.0268 ## 2 1988 F Ashley 49961 0.0260 ## 3 1988 F Amanda 39455 0.0205 ## 4 1988 F Sarah 28366 0.0148 ## 5 1988 F Jennifer 27887 0.0145 ## 6 1988 F Brittany 26815 0.0139 or keep observations of only popular names: Name_Pop &lt;- filter(Name_Data, prop &gt;= 0.07) head(Name_Pop) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 ## 2 1880 M John 9655 0.0815 ## 3 1880 M William 9532 0.0805 ## 4 1881 M John 8769 0.0810 ## 5 1881 M William 8524 0.0787 ## 6 1882 F Mary 8148 0.0704 Notice how we saved the new data under a different object name (Name_MyYear). When using filter(), you should never replace/ overwrite your original data unless you know exactly what you are doing. What could be the consequences? By the way, what do symbols such == and &gt;= remind you of??? (hint: something we covered last week?) Answers Consequences: You could potentially lose some data. Nothing is ever completely lost though (unless you are overwriting the original .csv file) but it could result in more work for you to restore everything from the beginning. Especially when your data scripts are very long and analysis is complex (i.e. taking up a lot of computing power), that could easily turn into a nightmare. Remember the relational operators that returned logical values of either TRUE or FALSE? Relational operators (such as ==, !=, &lt;, &lt;=, &gt;, and &gt;=) compare two numerical expressions and return a Boolean variable: a variable whose value is either 0 (FALSE) or 1 (TRUE). So, essentially, filter() includes any observations (rows) for which the expression evaluates to TRUE, and excludes any for which it evaluates to FALSE. In the previous example, filter() sifted through 1924665 observations, keeping rows containing year that was equal to 1998. This works as well for columns of the data type character. If you want only those observations for a specific name, you could use the equivalence operator ==. Be aware that a single equals sign (=) is used to assign a value to a variable whereas a double equals sign (==) is used to check whether two values are equal. Name_Me &lt;- filter(Name_Data, name == &quot;Jaimie&quot;) head(Name_Me) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1946 F Jaimie 7 0.00000434 ## 2 1948 F Jaimie 5 0.00000287 ## 3 1951 F Jaimie 8 0.00000433 ## 4 1952 F Jaimie 8 0.00000421 ## 5 1953 F Jaimie 6 0.00000311 ## 6 1954 F Jaimie 8 0.00000402 Here, the filter() function compares every single value in the column name of the data object Name_Data with the character string written on the right-hand side of the equation (“Jaimie”). You can also use filter() to keep data from multiple options of the same variable using the %in% operator. In this case we want to filter several different names: Name_J &lt;- filter(Name_Data, name %in% c(&quot;Jaimie&quot;, &quot;Jamie&quot;, &quot;Jaime&quot;, &quot;James&quot;, &quot;Jayme&quot;)) head(Name_J) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F James 22 0.000225 ## 2 1880 M James 5927 0.0501 ## 3 1881 F James 24 0.000243 ## 4 1881 M James 5441 0.0502 ## 5 1882 F James 18 0.000156 ## 6 1882 M James 5892 0.0483 Because filter() evalutes variables against your criteria and keeps observations that are TRUE, in essence the function defaults to “filter-in” certain observations. You can however also use it to “filter-out” specific observations, by using the ‘not equals’ operator !=. Here filter() keeps every row in which the value DOES NOT read what you have specificed. Using filter() to exclude certain observations. Name_J_Short &lt;- filter(Name_J, name !=&quot;James&quot;) head(Name_J_Short) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1884 F Jamie 5 0.0000363 ## 2 1887 F Jamie 5 0.0000322 ## 3 1888 F Jamie 5 0.0000264 ## 4 1890 F Jamie 12 0.0000595 ## 5 1891 F Jamie 11 0.0000560 ## 6 1892 F Jamie 10 0.0000445 3.5.2 Multiple criteria Often you will come across a situation where you will need to filter based on multiple criteria. For that you have the options of AND and OR. ANDis used if you had two criteria and only wanted data returned when both criteria are met. ORis used if you had two criteria and wanted data returned for either criterion. Simple Example: Just imagine, you have data of men and women who are either blond or dark-haired. If you wanted to filter everyone who has blond hair AND is a man, all your data looks like this: Whereas, if you wanted to filter out everyone who has either dark hair OR is a woman, you would get: What does that mean for our babynames data? For example, to filter rows containing only your name, of one sex, since your year of birth, you would code: Name_Specific &lt;- filter(Name_Data, name == &quot;Jaimie&quot;, year &gt;= 1988, sex == &quot;M&quot;) head(Name_Specific) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1988 M Jaimie 22 0.0000110 ## 2 1989 M Jaimie 15 0.00000716 ## 3 1990 M Jaimie 28 0.0000130 ## 4 1991 M Jaimie 21 0.00000991 ## 5 1992 M Jaimie 19 0.00000905 ## 6 1993 M Jaimie 14 0.00000678 You could have also used the logical operator &amp; (AND) instead of the comma. filter(Name_Data, name == “Jaimie” &amp; year &gt;= 1988 &amp; sex == “M”) would have given you the same result as above. If we wanted to filter the data Name_Data for either names with a very high count OR names that account for a very low proportion, we could use the logical operator | (OR). Data_Or &lt;- filter(Name_Data, n &gt; 90000 | prop &lt; 2.27e-06) head(Data_Or) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1947 F Linda 99686 0.0548 ## 2 1947 M James 94756 0.0510 ## 3 1947 M Robert 91642 0.0493 ## 4 1948 F Linda 96209 0.0552 ## 5 1949 F Linda 91016 0.0518 ## 6 1956 M Michael 90620 0.0423 As you will have noticed, Data_Or has now observations for names that either have a count over 90,000 in a year, or account for a very small proportion in a year. In this instance these are very distinct groups, and no observation would meet both criteria, check for yourself: Data_Or2 &lt;- filter(Name_Data, n &gt; 90000 &amp; prop &lt; 2.27e-06) head(Data_Or2) ## # A tibble: 0 × 5 ## # ℹ 5 variables: year &lt;dbl&gt;, sex &lt;chr&gt;, name &lt;chr&gt;, n &lt;int&gt;, prop &lt;dbl&gt; Here we see Data_Or2, returns no observations. However sometimes, you might select multiple criteria, where some observations will only meet one, but other observations may meet both criteria (see below). So always keep in mind what exactly you want to find, and choose the best way to filter. Data_Or3 &lt;- filter(Name_Data, n &gt; 90000 | prop &gt; 0.05) head(Data_Or3) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 ## 2 1880 M John 9655 0.0815 ## 3 1880 M William 9532 0.0805 ## 4 1880 M James 5927 0.0501 ## 5 1881 F Mary 6919 0.0700 ## 6 1881 M John 8769 0.0810 Data_Or4 &lt;- filter(Name_Data, n &gt; 90000 &amp; prop &gt; 0.05) head(Data_Or4) ## # A tibble: 4 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1947 F Linda 99686 0.0548 ## 2 1947 M James 94756 0.0510 ## 3 1948 F Linda 96209 0.0552 ## 4 1949 F Linda 91016 0.0518 Question Time How many rows (or observations) does the object Data_Or3 contain? How many different female names are in Data_Or4? Your turn Make a tibble called Name_Beat that only shows data from Name_Data for the names John, Paul, George and Ringo, and just for sex males. Solution Name_Beat &lt;- filter(Name_Data, name %in% c(&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;), sex == &quot;M&quot;) # If you have done this correct you should be able to produce a nice simple plot with the code below, to show change in proportional representation of these names over time (don&#39;t worry about what this code means, you&#39;ll learn more about plots later in the course) ggplot(Name_Beat, aes(year, prop, colour=name)) + geom_line() 3.6 mutate() The mutate() function creates new variables (columns) onto the existing object. The first argument to this function is an object from your Global Environment (for example Name_Data) and the subsequent argument is the new column name and what you want it to contain. The following image was downloaded from https://www.sharpsightlabs.com/blog/mutate-in-r/ Let’s apply this to this to our Name_Data data tibble. Say we wanted to create a new column Decade that shows us the relative decade each observation is taken from. Save this as a new object Name_Ext to the Global Environment rather than overwriting Name_Data so that we can compare Name_Data with the extended Name_Ext later on. Name_Ext &lt;- mutate(Name_Data, Decade = floor(year/10)*10) head(Name_Ext) ## # A tibble: 6 × 6 ## year sex name n prop Decade ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 1880 ## 2 1880 F Anna 2604 0.0267 1880 ## 3 1880 F Emma 2003 0.0205 1880 ## 4 1880 F Elizabeth 1939 0.0199 1880 ## 5 1880 F Minnie 1746 0.0179 1880 ## 6 1880 F Margaret 1578 0.0162 1880 As we can see, Name_Ext has one column more than Name_Data. So mutate() took the value in the cells for each row of the variable year, devided it by 10, and using the floor() function, rounds that value down to the nearest whole number, before finally multiplying the result by 10, and adding it to a new column called Decade. Importantly, new variables will overwrite existing variables if column headings are identical. So if we wanted to halve the values in column Decade and store them in a column Decade, the original Decade would be overwritten. To demonstrate we will try doing this and stroring the output in a new object called Name_Ext2and save that to our Global Environment. Name_Ext2 &lt;- mutate(Name_Ext, Decade = Decade/2) head(Name_Ext2) ## # A tibble: 6 × 6 ## year sex name n prop Decade ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 940 ## 2 1880 F Anna 2604 0.0267 940 ## 3 1880 F Emma 2003 0.0205 940 ## 4 1880 F Elizabeth 1939 0.0199 940 ## 5 1880 F Minnie 1746 0.0179 940 ## 6 1880 F Margaret 1578 0.0162 940 So now, Name_Ext2 did not gain a column (it still contains 6 variables), and Decade now has (unhelpfully) half the numeric value of the decade. (As an aside you could prevent yourself from accidentally doing something like this by converting Decade from numeric double type data to character type data, if you had no intention of carrying out any calculations on that variable) The main take-away message here is to always check your data after manipulation if the outcome is really what you would expected. If you don’t inspect and accidentally overwrite columns, you would not notice any difference. You can also use mutate() to drop columns you no longer need, as an alternative to the select() function. This would mean that Name_Ext2 is now identical to Name_Data. Name_Ext2 &lt;- mutate(Name_Ext2, Decade = NULL) head(Name_Ext2) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 ## 2 1880 F Anna 2604 0.0267 ## 3 1880 F Emma 2003 0.0205 ## 4 1880 F Elizabeth 1939 0.0199 ## 5 1880 F Minnie 1746 0.0179 ## 6 1880 F Margaret 1578 0.0162 If you want to add more than 2 columns, you can do that in a single mutate() statement. You can also add variables that are not numerical values, such as character or logical. Add two columns to Name_Ext and call it Name_Ext3. Column 1 is called MinName and is of datatype logical. It contains a comparison of the value in n with the cut off count of 5 that allows inclusion in the dataset. Values of 5 should read TRUE, all other values FALSE. Column 2 is called \"20thCent\" and is of datatype logical. It contains a comparison of the value in years ensuring the value is between 1900 and 1999. Values inside this range should read TRUE, all other values FALSE. Name_Ext3 &lt;- mutate(Name_Ext, MinName = n == 5, &quot;20thCent&quot; = year &gt;= 1900 &amp; year &lt;= 1999) head(Name_Ext3) ## # A tibble: 6 × 8 ## year sex name n prop Decade MinName `20thCent` ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 1880 F Mary 7065 0.0724 1880 FALSE FALSE ## 2 1880 F Anna 2604 0.0267 1880 FALSE FALSE ## 3 1880 F Emma 2003 0.0205 1880 FALSE FALSE ## 4 1880 F Elizabeth 1939 0.0199 1880 FALSE FALSE ## 5 1880 F Minnie 1746 0.0179 1880 FALSE FALSE ## 6 1880 F Margaret 1578 0.0162 1880 FALSE FALSE You may have noticed we needed to put the name of our new column “20thCent” inside quotation marks. This is because that name would begin with numeric values which R will interpret as numeric values to be evaluated as code by default, which will then break our code. By placeing the name within quotation marks this tells R to treat this as a standard character string instead. It is always best to avoid creating variables with names that start with a number for this reason, but if it is necessary this is how you can work around it. We can also specify where we want our new column to go by specifying which existing column we want it to go .before or .after. For example, we could create a new column in Name_Data that has the total number expressed in thousands and rounded to the nearest hundred, and we could put this just after the n column: Name_After &lt;- mutate(Name_Data, thousands = paste0(as.character(round(n/1000,1)),&#39;k&#39;), .after = n) head(Name_After) ## # A tibble: 6 × 6 ## year sex name n thousands prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 7.1k 0.0724 ## 2 1880 F Anna 2604 2.6k 0.0267 ## 3 1880 F Emma 2003 2k 0.0205 ## 4 1880 F Elizabeth 1939 1.9k 0.0199 ## 5 1880 F Minnie 1746 1.7k 0.0179 ## 6 1880 F Margaret 1578 1.6k 0.0162 Here the paste0 function pastes two character strings together with 0 spaces in between. We could also specify a numeric column position rather than a name to determine where we want mutate() to put a new column. Let’s add a column that tells us the century just before the year column: Name_Before &lt;- mutate(Name_Data, century = paste0(as.character(floor(year/100)+1),&#39;th&#39;), .before = 1) head(Name_Before) ## # A tibble: 6 × 6 ## century year sex name n prop ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 19th 1880 F Mary 7065 0.0724 ## 2 19th 1880 F Anna 2604 0.0267 ## 3 19th 1880 F Emma 2003 0.0205 ## 4 19th 1880 F Elizabeth 1939 0.0199 ## 5 19th 1880 F Minnie 1746 0.0179 ## 6 19th 1880 F Margaret 1578 0.0162 You might have realised that we would run into a problem in the Name_Before example whereby we would have 19th, 20th, and 21th centuries! To do this properly, we would need some way to tell R to paste ‘st’, ‘nd’, or ‘rd’ IF the number ends in in 1, 2, or 3, ELSE paste ‘th’. You will have to stay tuned for Chapter 5 to find out more!! Question Time Your turn Add a new column to Name_Data that is called prcnt and is positioned to the left of prop that gives the percentage each name accounts for of total names that year. *Hint: prop (proportion) is like a percentage represented out of 1 instead of out of 100! Solution # Sean&#39;s solutions Name_Ext4 &lt;- mutate(Name_Data, prcnt = prop * 100, .before = prop) # or Name_Ext4 &lt;- mutate(Name_Data, prcnt = prop * 100, .before = ncol(Name_Data)) # or Name_Ext4 &lt;- mutate(Name_Data, prcnt = prop * 100, .before = 5) # or Name_Ext4 &lt;- mutate(Name_Data, prcnt = prop * 100, .after = 4) # or Name_Ext4 &lt;- mutate(Name_Data, prcnt = prop * 100, .after = n) head(Name_Ext4) ## # A tibble: 6 × 6 ## year sex name n prcnt prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 7.24 0.0724 ## 2 1880 F Anna 2604 2.67 0.0267 ## 3 1880 F Emma 2003 2.05 0.0205 ## 4 1880 F Elizabeth 1939 1.99 0.0199 ## 5 1880 F Minnie 1746 1.79 0.0179 ## 6 1880 F Margaret 1578 1.62 0.0162 3.6.1 Read in second dataset At this point we are reaching the end of the usefulness of the Babynames dataset (there is only so much you can do with 5 basic variables), and this is a good time to bring in the second dataset we mentioned. The second dataset, is a set of career and performance statistics of MMA athletes. You need to read the file CareerStats.csv containing your data into your Global Environment using the function read_csv(). Remember to store your data in an appropriately named object (e.g. MMA_Data). MMA_Data &lt;- read_csv(&quot;data/CareerStats.csv&quot;) ## Rows: 199 Columns: 32 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): ID, HeightClass, ReachClass, Stance, WeightClass ## dbl (27): Age, Height, Weight, BMI, Reach, T_Wins, T_Losses, T_Fights, Succe... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. As you can see this dataset has a lot more variables, which should make for more interesting ways of manipulating the data. 3.7 summarise() In order to compute summary statistics such as mean, median and standard deviation, use the summarise() function. This function creates a new tibble of your desired summary statistics. The first argument to this function is the data you are interested in summarising; in this case the object MMA_Data, and the subsequent argument is the new column name and what mathematical operation you want it to contain. You can add as many summary statistics in one summarise() function as you want; just separate them by a comma. You can use the help function to find out more about the kind of summary stats you can extract. Some of the most useful however are: sum() - sum total n() - count of observations n_distinct() - count of distinct (unique) observations mean() - measure of central tendency; mean median() - measure of central tendency; median sd() - standard deviation IQR() - interquartile range min() - the maximum available value in observations max() - the minimum available value in observations Lets start generating some summary stats. For example, say you want to work out the average number of total fights (T_Fights) among the athletes and accompanying standard deviation for the entire sample: summarise(MMA_Data, Avg_Mean = mean(T_Fights), SD = sd(T_Fights)) ## # A tibble: 1 × 2 ## Avg_Mean SD ## &lt;dbl&gt; &lt;dbl&gt; ## 1 23.0 9.80 Therefore, the average number of total fights for all the athletes in our sample is 22.98, with a standard deviation of 9.8. Let’s try another. what is the maximum and minimum hights for the entire sample? summarise(MMA_Data, Minimum = min(Height), Maximum = max(Height)) ## # A tibble: 1 × 2 ## Minimum Maximum ## &lt;dbl&gt; &lt;dbl&gt; ## 1 63 83 Or maybe we want to know how many different (distinct) weightclasses are there in our dataset? How would we check that? summarise(MMA_Data, WeightClasses = n_distinct(WeightClass)) ## # A tibble: 1 × 1 ## WeightClasses ## &lt;int&gt; ## 1 8 3.8 Adding group_by() Now that’s all well and good, but in research we are most often interested in drawing comparisons and analysing differences (Between different groups of people, between different treatment types, between different countries etc.). This is where the group_by() function comes in handy. It can organise observations (rows) by variables (columns), thereby spliting the data up into subsets that can be analysed independently. The first argument to this function is the data you wish to organise, in this case MMA_Data and the subsequent argument is your chosen grouping variable you want to organise by (e.g. group by). Here we are grouping by weightclass, and saving this as a new object MMA_G_Weight; MMA_G_Weight &lt;- group_by(MMA_Data, WeightClass) If you view the object MMA_G_Class, it will not look any different to the original dataset (MMA_Data). However, be aware that the underlying structure has changed. In fact, you could use glimpse() to double check this. glimpse(MMA_G_Weight) ## Rows: 199 ## Columns: 32 ## Groups: WeightClass [8] ## $ ID &lt;chr&gt; &quot;056c493bbd76a918&quot;, &quot;b102c26727306ab6&quot;, &quot;80eacd4da0617c5… ## $ Age &lt;dbl&gt; 31.88, 33.70, 34.41, 25.39, 31.02, 34.77, 33.97, 28.70, … ## $ Height &lt;dbl&gt; 64, 65, 64, 64, 65, 66, 64, 65, 65, 66, 67, 65, 68, 65, … ## $ HeightClass &lt;chr&gt; &quot;Short&quot;, &quot;Short&quot;, &quot;Short&quot;, &quot;Short&quot;, &quot;Short&quot;, &quot;Average&quot;, … ## $ Weight &lt;dbl&gt; 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 135, 1… ## $ BMI &lt;dbl&gt; 21.454, 20.799, 21.454, 21.454, 20.799, 20.173, 21.454, … ## $ Reach &lt;dbl&gt; 64, 67, 65, 63, 68, 66, 65, 67, 65, 65, 66, 65, 70, 68, … ## $ ReachClass &lt;chr&gt; &quot;Below&quot;, &quot;Below&quot;, &quot;Below&quot;, &quot;Below&quot;, &quot;Below&quot;, &quot;Below&quot;, &quot;B… ## $ Stance &lt;chr&gt; &quot;Orthodox&quot;, &quot;Orthodox&quot;, &quot;Southpaw&quot;, &quot;Orthodox&quot;, &quot;Orthodo… ## $ WeightClass &lt;chr&gt; &quot;Flyweight&quot;, &quot;Flyweight&quot;, &quot;Flyweight&quot;, &quot;Flyweight&quot;, &quot;Fly… ## $ T_Wins &lt;dbl&gt; 13, 22, 26, 11, 15, 19, 23, 20, 19, 21, 15, 14, 12, 10, … ## $ T_Losses &lt;dbl&gt; 2, 5, 5, 3, 0, 7, 9, 3, 7, 5, 8, 1, 1, 5, 5, 4, 5, 2, 2,… ## $ T_Fights &lt;dbl&gt; 15, 27, 31, 14, 15, 26, 32, 23, 26, 26, 24, 15, 13, 15, … ## $ Success &lt;dbl&gt; 0.867, 0.815, 0.839, 0.786, 1.000, 0.731, 0.719, 0.870, … ## $ W_by_Decision &lt;dbl&gt; 8, 12, 10, 4, 2, 8, 13, 6, 7, 11, 6, 7, 7, 1, 5, 3, 3, 5… ## $ `W_by_KO/TKO` &lt;dbl&gt; 5, 10, 7, 1, 8, 8, 0, 6, 8, 4, 3, 2, 2, 8, 2, 2, 1, 4, 2… ## $ W_by_Sub &lt;dbl&gt; 0, 0, 9, 6, 5, 3, 10, 8, 4, 6, 6, 5, 3, 1, 5, 6, 10, 4, … ## $ L_by_Decision &lt;dbl&gt; 1, 3, 4, 2, 0, 4, 5, 3, 6, 1, 4, 0, 1, 3, 5, 1, 5, 0, 1,… ## $ `L_by_KO/TKO` &lt;dbl&gt; 1, 2, 1, 0, 0, 2, 3, 0, 0, 1, 1, 1, 0, 0, 0, 2, 0, 2, 1,… ## $ L_by_Sub &lt;dbl&gt; 0, 0, 0, 1, 0, 1, 1, 0, 1, 3, 3, 0, 0, 2, 0, 1, 0, 0, 0,… ## $ PWDec &lt;dbl&gt; 0.533, 0.444, 0.323, 0.286, 0.133, 0.308, 0.406, 0.261, … ## $ PWTko &lt;dbl&gt; 0.333, 0.370, 0.226, 0.071, 0.533, 0.308, 0.000, 0.261, … ## $ PWSub &lt;dbl&gt; 0.000, 0.000, 0.290, 0.429, 0.333, 0.115, 0.312, 0.348, … ## $ PLDec &lt;dbl&gt; 0.067, 0.111, 0.129, 0.143, 0.000, 0.154, 0.156, 0.130, … ## $ PLTko &lt;dbl&gt; 0.067, 0.074, 0.032, 0.000, 0.000, 0.077, 0.094, 0.000, … ## $ PLSub &lt;dbl&gt; 0.000, 0.000, 0.000, 0.071, 0.000, 0.038, 0.031, 0.000, … ## $ Available &lt;dbl&gt; 9, 12, 24, 8, 4, 14, 12, 5, 15, 4, 10, 2, 1, 6, 5, 4, 5,… ## $ TTime &lt;dbl&gt; 123.234, 137.034, 278.699, 113.466, 42.700, 168.316, 145… ## $ Time_Avg &lt;dbl&gt; 13.693, 11.419, 11.612, 14.183, 10.675, 12.023, 12.127, … ## $ TLpM &lt;dbl&gt; 5.461, 3.196, 4.410, 2.732, 3.115, 3.624, 3.828, 5.851, … ## $ AbpM &lt;dbl&gt; 2.605, 2.167, 2.515, 1.921, 1.616, 2.549, 2.948, 3.377, … ## $ SubAtt_Avg &lt;dbl&gt; 0.122, 0.657, 0.700, 1.454, 3.864, 1.069, 0.618, 1.755, … You can now feed this grouped dataset (MMA_G_Weight) into the previous code line to obtain summary statistics by WeightClass, the code for finding summary statistics of average number of total fights, has been provided.: Sum_Fights &lt;- summarise(MMA_G_Weight, Avg_Mean = mean(T_Fights), SD = sd(T_Fights)) Question Time Which weightclass has the highest maximum height? Solution Sum_Height &lt;- summarise(MMA_G_Weight, Minimum = min(Height), Maximum = max(Height)) You can technically group by any variable! For example, there is nothing stopping you from grouping by a continuous variable like age or height. R will allow you to group by a numerical variable that is type double, the code will run. However you probably want to be more careful in choosing a categorical variable as grouping criteria. These will usually be character, or interger or even logical data types. However interger data type might also actually represent a continuous variable (but might have only been recorded in whole numbers), and a variable that is character type may not represent a useful category (like idividual ID’s for example). The point is R does not know what your dataset is actually about, and what your variables are meant to represent… R has no idea if your variable should be categorical or not. So it’s up to you to know what are sensible variables to use in the group_by() function. You might also want to calculate and display the number of individuals from your dataset that are in different groups. This can be achieved by adding the summary function n() once you have grouped your data. the function n(), simply counts the number of observations and takes no arguments. Here we will group by Stance and count the number of athelets in each category: MMA_G_Stance &lt;- group_by(MMA_Data, Stance) Stance_Ns &lt;- summarise(MMA_G_Stance, N = n()) Stance_Ns ## # A tibble: 3 × 2 ## Stance N ## &lt;chr&gt; &lt;int&gt; ## 1 Orthodox 140 ## 2 Southpaw 45 ## 3 Switch 14 Question Time How many athletes in the dataset have a Southpaw stance? How many athletes in the dataset have an Orthodox stance? Finally, it is possible to add multiple grouping variables. For example, the following code groups MMA_Data by ReachClass and Stance and then calculates the mean and standard deviation of average number of strikes landed per minute (TLpM) for each group (6 groups). MMA_G_RS &lt;- group_by(MMA_Data, ReachClass, Stance) MMA_LpM &lt;- summarise(MMA_G_RS, Mean = mean(TLpM), SD = sd(TLpM)) ## `summarise()` has grouped output by &#39;ReachClass&#39;. You can override using the ## `.groups` argument. MMA_LpM ## # A tibble: 6 × 4 ## # Groups: ReachClass [2] ## ReachClass Stance Mean SD ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Above Orthodox 5.44 1.66 ## 2 Above Southpaw 4.68 1.16 ## 3 Above Switch 5.92 1.29 ## 4 Below Orthodox 5.33 1.60 ## 5 Below Southpaw 5.02 1.47 ## 6 Below Switch 5.95 3.63 So far we have not had to calculate any summary statistics with any missing values, denoted by NA in R. Missing values are always a bit of a hassle to deal with. Any computation you do that involves NA returns an NA - which translates as “you will not get a numeric result when your column contains missing values”. Missing values can be removed by adding the argument na.rm = TRUE to calculation functions like mean(), median() or sd(). For example, lets try to calulate a mean where we have some missing values: Weight_Reach &lt;- summarise(MMA_G_Weight, Avg_Reach = mean(Reach)) Weight_Reach ## # A tibble: 8 × 2 ## WeightClass Avg_Reach ## &lt;chr&gt; &lt;dbl&gt; ## 1 Bantamweight 67.8 ## 2 Featherweight 71.0 ## 3 Flyweight 66.9 ## 4 Heavyweight NA ## 5 LightHeavyweight 76.9 ## 6 Lightweight 72.6 ## 7 Middleweight NA ## 8 Welterweight 74 The code runs without error, however you will notice we have a few stats missing (NA). Now lets tell R to remove any missing values when making its calculation. Weight_Reach &lt;- summarise(MMA_G_Weight, Avg_Reach = mean(Reach, na.rm = T)) Weight_Reach ## # A tibble: 8 × 2 ## WeightClass Avg_Reach ## &lt;chr&gt; &lt;dbl&gt; ## 1 Bantamweight 67.8 ## 2 Featherweight 71.0 ## 3 Flyweight 66.9 ## 4 Heavyweight 78.0 ## 5 LightHeavyweight 76.9 ## 6 Lightweight 72.6 ## 7 Middleweight 75.4 ## 8 Welterweight 74 Finally… If you need to return the data to a non-grouped form, use the ungroup() function. MMA_Data &lt;- group_by(MMA_Data, BMI) glimpse(MMA_Data) ## Rows: 199 ## Columns: 32 ## Groups: BMI [70] ## $ ID &lt;chr&gt; &quot;056c493bbd76a918&quot;, &quot;b102c26727306ab6&quot;, &quot;80eacd4da0617c5… ## $ Age &lt;dbl&gt; 31.88, 33.70, 34.41, 25.39, 31.02, 34.77, 33.97, 28.70, … ## $ Height &lt;dbl&gt; 64, 65, 64, 64, 65, 66, 64, 65, 65, 66, 67, 65, 68, 65, … ## $ HeightClass &lt;chr&gt; &quot;Short&quot;, &quot;Short&quot;, &quot;Short&quot;, &quot;Short&quot;, &quot;Short&quot;, &quot;Average&quot;, … ## $ Weight &lt;dbl&gt; 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 135, 1… ## $ BMI &lt;dbl&gt; 21.454, 20.799, 21.454, 21.454, 20.799, 20.173, 21.454, … ## $ Reach &lt;dbl&gt; 64, 67, 65, 63, 68, 66, 65, 67, 65, 65, 66, 65, 70, 68, … ## $ ReachClass &lt;chr&gt; &quot;Below&quot;, &quot;Below&quot;, &quot;Below&quot;, &quot;Below&quot;, &quot;Below&quot;, &quot;Below&quot;, &quot;B… ## $ Stance &lt;chr&gt; &quot;Orthodox&quot;, &quot;Orthodox&quot;, &quot;Southpaw&quot;, &quot;Orthodox&quot;, &quot;Orthodo… ## $ WeightClass &lt;chr&gt; &quot;Flyweight&quot;, &quot;Flyweight&quot;, &quot;Flyweight&quot;, &quot;Flyweight&quot;, &quot;Fly… ## $ T_Wins &lt;dbl&gt; 13, 22, 26, 11, 15, 19, 23, 20, 19, 21, 15, 14, 12, 10, … ## $ T_Losses &lt;dbl&gt; 2, 5, 5, 3, 0, 7, 9, 3, 7, 5, 8, 1, 1, 5, 5, 4, 5, 2, 2,… ## $ T_Fights &lt;dbl&gt; 15, 27, 31, 14, 15, 26, 32, 23, 26, 26, 24, 15, 13, 15, … ## $ Success &lt;dbl&gt; 0.867, 0.815, 0.839, 0.786, 1.000, 0.731, 0.719, 0.870, … ## $ W_by_Decision &lt;dbl&gt; 8, 12, 10, 4, 2, 8, 13, 6, 7, 11, 6, 7, 7, 1, 5, 3, 3, 5… ## $ `W_by_KO/TKO` &lt;dbl&gt; 5, 10, 7, 1, 8, 8, 0, 6, 8, 4, 3, 2, 2, 8, 2, 2, 1, 4, 2… ## $ W_by_Sub &lt;dbl&gt; 0, 0, 9, 6, 5, 3, 10, 8, 4, 6, 6, 5, 3, 1, 5, 6, 10, 4, … ## $ L_by_Decision &lt;dbl&gt; 1, 3, 4, 2, 0, 4, 5, 3, 6, 1, 4, 0, 1, 3, 5, 1, 5, 0, 1,… ## $ `L_by_KO/TKO` &lt;dbl&gt; 1, 2, 1, 0, 0, 2, 3, 0, 0, 1, 1, 1, 0, 0, 0, 2, 0, 2, 1,… ## $ L_by_Sub &lt;dbl&gt; 0, 0, 0, 1, 0, 1, 1, 0, 1, 3, 3, 0, 0, 2, 0, 1, 0, 0, 0,… ## $ PWDec &lt;dbl&gt; 0.533, 0.444, 0.323, 0.286, 0.133, 0.308, 0.406, 0.261, … ## $ PWTko &lt;dbl&gt; 0.333, 0.370, 0.226, 0.071, 0.533, 0.308, 0.000, 0.261, … ## $ PWSub &lt;dbl&gt; 0.000, 0.000, 0.290, 0.429, 0.333, 0.115, 0.312, 0.348, … ## $ PLDec &lt;dbl&gt; 0.067, 0.111, 0.129, 0.143, 0.000, 0.154, 0.156, 0.130, … ## $ PLTko &lt;dbl&gt; 0.067, 0.074, 0.032, 0.000, 0.000, 0.077, 0.094, 0.000, … ## $ PLSub &lt;dbl&gt; 0.000, 0.000, 0.000, 0.071, 0.000, 0.038, 0.031, 0.000, … ## $ Available &lt;dbl&gt; 9, 12, 24, 8, 4, 14, 12, 5, 15, 4, 10, 2, 1, 6, 5, 4, 5,… ## $ TTime &lt;dbl&gt; 123.234, 137.034, 278.699, 113.466, 42.700, 168.316, 145… ## $ Time_Avg &lt;dbl&gt; 13.693, 11.419, 11.612, 14.183, 10.675, 12.023, 12.127, … ## $ TLpM &lt;dbl&gt; 5.461, 3.196, 4.410, 2.732, 3.115, 3.624, 3.828, 5.851, … ## $ AbpM &lt;dbl&gt; 2.605, 2.167, 2.515, 1.921, 1.616, 2.549, 2.948, 3.377, … ## $ SubAtt_Avg &lt;dbl&gt; 0.122, 0.657, 0.700, 1.454, 3.864, 1.069, 0.618, 1.755, … MMA_Data &lt;- ungroup(MMA_Data) head(MMA_Data) ## # A tibble: 6 × 32 ## ID Age Height HeightClass Weight BMI Reach ReachClass Stance ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 056c493bbd76a918 31.9 64 Short 125 21.5 64 Below Ortho… ## 2 b102c26727306ab6 33.7 65 Short 125 20.8 67 Below Ortho… ## 3 80eacd4da0617c57 34.4 64 Short 125 21.5 65 Below South… ## 4 a4de54ea806fb525 25.4 64 Short 125 21.5 63 Below Ortho… ## 5 aa72b0f831d0bfe5 31.0 65 Short 125 20.8 68 Below Ortho… ## 6 92437c6775b3f7d1 34.8 66 Average 125 20.2 66 Below Ortho… ## # ℹ 23 more variables: WeightClass &lt;chr&gt;, T_Wins &lt;dbl&gt;, T_Losses &lt;dbl&gt;, ## # T_Fights &lt;dbl&gt;, Success &lt;dbl&gt;, W_by_Decision &lt;dbl&gt;, `W_by_KO/TKO` &lt;dbl&gt;, ## # W_by_Sub &lt;dbl&gt;, L_by_Decision &lt;dbl&gt;, `L_by_KO/TKO` &lt;dbl&gt;, L_by_Sub &lt;dbl&gt;, ## # PWDec &lt;dbl&gt;, PWTko &lt;dbl&gt;, PWSub &lt;dbl&gt;, PLDec &lt;dbl&gt;, PLTko &lt;dbl&gt;, ## # PLSub &lt;dbl&gt;, Available &lt;dbl&gt;, TTime &lt;dbl&gt;, Time_Avg &lt;dbl&gt;, TLpM &lt;dbl&gt;, ## # AbpM &lt;dbl&gt;, SubAtt_Avg &lt;dbl&gt; 3.8.1 Bringing it together Let’s finish this section with an exercise that combines all of the Wickham Six functions. Question Time Your turn Starting with MMA_Data: Rename the column Success to be called WinRate, and select only the following columns in this specific order: WinRate, Stance, WeightClass Save the output as wick6a. Arrange the data in wick6a such that those with the highest WinRate are at the top and those with the lowest WinRate are at the bottom. Save the output as wick6b. Remove all rows in Wick6b where the fighter stance is Orthodox. Save the output as wick6c. Add a column to wick6c in the first position (leftmost) called Rank which contains the number 1 for the highest winrate fighter, 2 for the second highest, and so on. Save the output as wick6d. Group wick6d by WeightClass. Save the output as wick6e. Create a summary of wick6e that shows the mean winrate for each weight class in a column called WinRate_Average. Save the output as wick6f. Solution #Sean&#39;s solution wick6a &lt;- select(MMA_Data, WinRate = Success, Stance, WeightClass) wick6b &lt;- arrange(wick6a, desc(WinRate)) wick6c &lt;- filter(wick6b, Stance != &quot;Orthodox&quot;) wick6d &lt;- mutate(wick6c, Rank = 1:nrow(wick6c), .before = 1) wick6e &lt;- group_by(wick6d, WeightClass) wick6f &lt;- summarise(wick6e, WinRate_Average = mean(WinRate)) wick6f ## # A tibble: 8 × 2 ## WeightClass WinRate_Average ## &lt;chr&gt; &lt;dbl&gt; ## 1 Bantamweight 0.776 ## 2 Featherweight 0.799 ## 3 Flyweight 0.760 ## 4 Heavyweight 0.831 ## 5 LightHeavyweight 0.782 ## 6 Lightweight 0.750 ## 7 Middleweight 0.815 ## 8 Welterweight 0.791 3.9 The pipe operator (%&gt;%) As you may have noticed, your environment pane has become increasingly cluttered. Indeed, every time you introduced a new line of code, you created a uniquely-named object (unless your original object is overwritten). This can become confusing and time-consuming. One solution is the pipe operator (%&gt;%) which aims to increase efficiency and improve the readability of your code. The pipe operator (%&gt;%) can be read as “and then”, and it allows you to chain functions together, eliminating the need to create intermediary objects. This creates a “pipeline”, allowing the “flow” of data between lines of code, as the output of one function “flows” into the next function. There is no limit as to how many functions you can chain together in a single pipeline. For example, in order to select(), arrange() and filter() the data in the previous exercise, you had to do something like this: wick6a &lt;- select(MMA_Data, WinRate = Success, Stance, WeightClass) wick6b &lt;- arrange(wick6a, desc(WinRate)) wick6c &lt;- filter(wick6b, Stance != &quot;Orthodox&quot;) head(wick6c) ## # A tibble: 6 × 3 ## WinRate Stance WeightClass ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Switch Middleweight ## 2 1 Switch Middleweight ## 3 1 Southpaw LightHeavyweight ## 4 0.944 Southpaw Welterweight ## 5 0.933 Switch Welterweight ## 6 0.929 Southpaw Featherweight However, utilisation of the pipe operator (%&gt;%) can simplify this process and create only one object as shown: wick6_onestep &lt;- MMA_Data %&gt;% select(WinRate = Success, Stance, WeightClass) %&gt;% arrange(desc(WinRate)) %&gt;% filter(Stance != &quot;Orthodox&quot;) head(wick6_onestep) ## # A tibble: 6 × 3 ## WinRate Stance WeightClass ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Switch Middleweight ## 2 1 Switch Middleweight ## 3 1 Southpaw LightHeavyweight ## 4 0.944 Southpaw Welterweight ## 5 0.933 Switch Welterweight ## 6 0.929 Southpaw Featherweight As you can see, wick6_onestep produces the same output as wick6c. So, how does it work? Well, pipes automatically take the output from one function and feed it directly into the first argument of the next function. Without pipes, you needed to insert your chosen dataset as the first argument to every function. With pipes, you are only required to specify the original dataset (i.e MMA_Data) once at the beginning of the pipeline, and removes the need to create unnecessary intermediary objects. You now no longer need the first argument of each of the subsequent functions anymore, because the pipe will know to look at the output from the previous step in the pipeline. 3.9.1 Magrittr Pipe (%&gt;%) vs. Base R Pipe (|&gt;) In this course we will use the pipe that exists as part of the magrittr package: %&gt;% This is the original pipe and is included as part of the tidyverse. However, it is worth noting that a base R pipe has since been added: |&gt; This works extremely similarly in most cases, and you may well encounter it as you encounter more R code. wick6_onestep &lt;- MMA_Data |&gt; select(WinRate = Success, Stance, WeightClass) |&gt; arrange(desc(WinRate)) |&gt; filter(Stance != &quot;Orthodox&quot;) head(wick6_onestep) ## # A tibble: 6 × 3 ## WinRate Stance WeightClass ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Switch Middleweight ## 2 1 Switch Middleweight ## 3 1 Southpaw LightHeavyweight ## 4 0.944 Southpaw Welterweight ## 5 0.933 Switch Welterweight ## 6 0.929 Southpaw Featherweight However, for this course we will be only using the magrittr pipe. Your turn Amend all of your code from the wick6 question and turn it into a single pipeline Save this as an object called wick6pipe to your Global Environment. Solution # Sean&#39;s solution wick6pipe &lt;- MMA_Data %&gt;% select(WinRate = Success, Stance, WeightClass) %&gt;% arrange(desc(WinRate)) %&gt;% filter(Stance != &quot;Orthodox&quot;) %&gt;% mutate(Rank = 1:nrow(wick6c), .before = 1) %&gt;% group_by(WeightClass) %&gt;% summarise(WinRate_Average = mean(WinRate)) wick6pipe ## # A tibble: 8 × 2 ## WeightClass WinRate_Average ## &lt;chr&gt; &lt;dbl&gt; ## 1 Bantamweight 0.776 ## 2 Featherweight 0.799 ## 3 Flyweight 0.760 ## 4 Heavyweight 0.831 ## 5 LightHeavyweight 0.782 ## 6 Lightweight 0.750 ## 7 Middleweight 0.815 ## 8 Welterweight 0.791 If done correctly wick6pipe should look identical to wick6f Note that in the above code chunk, the data object has been on its own line in the code followed immediately by %&gt;% before starting with the “functions”. The other option would have been to put the data object as the first argument within the first function like so: wick6pipe &lt;- select(MMA_Data, WinRate = Success, Stance, WeightClass) %&gt;% The benefit of having the data on its own is that you can reorder functions easily or squeeze another one in (for example if you summarised something but forgot to group beforehand) without the need to “move” the data object into the new first argument of the pipeline. It is mostly a convenience issue, and there may be times where one solution makes more sense than the other! 3.10 Pipe Practice with the Wickham Six The next part of this chapter will focus on practicing the Wickham Six functions, but this time we will be implementing piped solutions. 3.10.1 select() First up lets try to narrow down this big data set, by taking MMA_Data, and selecting only the variables; ID, Height, Weight, BMI, Reach and Stance. We will store this in Example_1. Example_1 &lt;- MMA_Data %&gt;% select(ID, Height, Weight:Reach, Stance) Example_1 ## # A tibble: 199 × 6 ## ID Height Weight BMI Reach Stance ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 056c493bbd76a918 64 125 21.5 64 Orthodox ## 2 b102c26727306ab6 65 125 20.8 67 Orthodox ## 3 80eacd4da0617c57 64 125 21.5 65 Southpaw ## 4 a4de54ea806fb525 64 125 21.5 63 Orthodox ## 5 aa72b0f831d0bfe5 65 125 20.8 68 Orthodox ## 6 92437c6775b3f7d1 66 125 20.2 66 Orthodox ## 7 5aedf14771ca82d2 64 125 21.5 65 Southpaw ## 8 a0f0004aadf10b71 65 125 20.8 67 Orthodox ## 9 f53c1f4ceeed8c08 65 125 20.8 65 Orthodox ## 10 ab2b4ff41d6ebe0f 66 125 20.2 65 Orthodox ## # ℹ 189 more rows Remember, this could also have been written as follows; Example_1 &lt;- MMA_Data %&gt;% select(ID, Height, Weight, BMI, Reach, Stance) We can use the : operator to sequence together columns that are next to each other in the original dataframe, this can save time but it is not necessary. Question Time Your turn Using select() keep everything from Example_1 except Reach, and store this in an object names Q1. Solution # Sean&#39;s solutions Q1 &lt;- Example_1 %&gt;% select(-Reach) #OR Q1 &lt;- Example_1 %&gt;% select(ID, Height, Weight, BMI, Stance) 3.10.2 arrange() Lets move on to arrange(); lets repeat the steps we did to make Example_1, and then arrange it first by Weight, then by BMI, we’ll store this in Example_2. Example_2 &lt;- MMA_Data %&gt;% select(ID, Height, Weight:Reach, Stance) %&gt;% arrange(Weight, BMI) Example_2 ## # A tibble: 199 × 6 ## ID Height Weight BMI Reach Stance ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 199eb7cf6ae90294 69 125 18.5 71 Orthodox ## 2 0fd5f4b838e890cc 68 125 19.0 70 Orthodox ## 3 67c1d46f4ed16f9e 68 125 19.0 70 Orthodox ## 4 792be9a24df82ed6 67 125 19.6 70 Orthodox ## 5 92437c6775b3f7d1 66 125 20.2 66 Orthodox ## 6 ab2b4ff41d6ebe0f 66 125 20.2 65 Orthodox ## 7 a0c64f272b65d441 66 125 20.2 68 Orthodox ## 8 1a31ef98efce7a79 66 125 20.2 66 Switch ## 9 2fe9032955c2e013 66 125 20.2 69 Switch ## 10 b102c26727306ab6 65 125 20.8 67 Orthodox ## # ℹ 189 more rows Question Time What is the height of the top entry in Example_2? Your turn In one continuous pipe chain: Take MMA_Data, rename the Height column so that it is called Tallness, and keep only the following columns IN THIS EXACT ORDER: ID, Weight, BMI, Reach, Stance, Tallness AND THEN use the arrange() function to sort first by Reach in descending order, then by Tallness in ascending order. Store the result in Q2. Solution # Sean&#39;s solution Q2 &lt;- MMA_Data %&gt;% select(ID, Weight:Reach, Stance, Tallness=Height) %&gt;% arrange(desc(Reach), Tallness) What is the BMI of the top entry in Q2? 3.10.3 filter() Now onto filter() which has so many uses! Lets filter out all the athletes who are over 31 years of age Example_3 &lt;- MMA_Data %&gt;% filter(Age &lt;=31) Example_3 ## # A tibble: 97 × 32 ## ID Age Height HeightClass Weight BMI Reach ReachClass Stance ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 a4de54ea806fb5… 25.4 64 Short 125 21.5 63 Below Ortho… ## 2 a0f0004aadf10b… 28.7 65 Short 125 20.8 67 Below Ortho… ## 3 f53c1f4ceeed8c… 30 65 Short 125 20.8 65 Below Ortho… ## 4 ab2b4ff41d6ebe… 26.8 66 Average 125 20.2 65 Below Ortho… ## 5 87f19d19f4cb73… 30.4 65 Short 125 20.8 65 Below Ortho… ## 6 0fd5f4b838e890… 26.7 68 Average 125 19.0 70 Below Ortho… ## 7 20999e27ddd94b… 29.3 65 Short 125 20.8 68 Below Ortho… ## 8 a0c64f272b65d4… 27.9 66 Average 125 20.2 68 Below Ortho… ## 9 67c1d46f4ed16f… 29.0 68 Average 125 19.0 70 Below Ortho… ## 10 792be9a24df82e… 25.0 67 Average 125 19.6 70 Below Ortho… ## # ℹ 87 more rows ## # ℹ 23 more variables: WeightClass &lt;chr&gt;, T_Wins &lt;dbl&gt;, T_Losses &lt;dbl&gt;, ## # T_Fights &lt;dbl&gt;, Success &lt;dbl&gt;, W_by_Decision &lt;dbl&gt;, `W_by_KO/TKO` &lt;dbl&gt;, ## # W_by_Sub &lt;dbl&gt;, L_by_Decision &lt;dbl&gt;, `L_by_KO/TKO` &lt;dbl&gt;, L_by_Sub &lt;dbl&gt;, ## # PWDec &lt;dbl&gt;, PWTko &lt;dbl&gt;, PWSub &lt;dbl&gt;, PLDec &lt;dbl&gt;, PLTko &lt;dbl&gt;, ## # PLSub &lt;dbl&gt;, Available &lt;dbl&gt;, TTime &lt;dbl&gt;, Time_Avg &lt;dbl&gt;, TLpM &lt;dbl&gt;, ## # AbpM &lt;dbl&gt;, SubAtt_Avg &lt;dbl&gt; Question Time How many athletes (observations) are left in Example_3? Your turn Using filter(), take the original table MMA_Data and keep only those athletes in the ‘Flyweight’ and ‘Lightweight’ WeightClasses Store the result in Q3. Solution # Sean&#39;s solution Q3 &lt;- MMA_Data %&gt;% filter(WeightClass %in% c(&quot;Flyweight&quot;, &quot;Lightweight&quot;)) How many athletes (observations) are left in Q3? Your turn Now try taking the original table MMA_Data and keep only those athletes from the “Welterweight” WeightClass, who are over 72 inches in Height. Store the result in Q4. Hint: remember they will need to match both conditions Solution # Sean&#39;s solution Q4 &lt;- MMA_Data %&gt;% filter(WeightClass == &quot;Welterweight&quot;, Height &gt; 72) How many athletes (observations) are left in Q4? Your turn In one continuous pipe chain: Take MMA_Data and keep only the Stance, T_Fights and W_by_Sub columns AND THEN Keep only those athletes who have the “Orthodox” Stance AND have 27 or more total fights (T_Fights) OR 15 or more wins by submission (W_by_Sub). Store the result in Q5. - Hint - No matter what they need to have the Orthodox stance, regardless of the other conditions Solution # Sean&#39;s solution Q5 &lt;- MMA_Data %&gt;% select(Stance, T_Fights, W_by_Sub) %&gt;% filter(Stance == &quot;Orthodox&quot; &amp; (T_Fights &gt;= 27 | W_by_Sub &gt;= 15)) #OR Q5 &lt;- MMA_Data %&gt;% select(Stance, T_Fights, W_by_Sub) %&gt;% filter(Stance == &quot;Orthodox&quot;, (T_Fights &gt;= 27 | W_by_Sub &gt;= 15)) Explain This Answer There is essentially 2 parts to this question; the first criteria is to find athletes who have the “orthodox” stance… that’s the first requirement… then if they matched that criteria, we want to check, if they have EITHER 27 or more total fights OR 15 or more wins by submission, which is why we need to put the second “either/or” criteria in brackets, so R knows to treat them together. If you take the brackets out, it will treat the first two criteria as a joint criteria and the | “Or” operator creates the break. Meaning R thinks you are asking for; Athletes with the orthodox stance and 27 or more total fights… OR athletes with 15 or more wins by submission. Try running the code without the brackets and seeing what happens Q5Alt &lt;- MMA_Data %&gt;% select(Stance, T_Fights, W_by_Sub) %&gt;% filter(Stance == “Orthodox” &amp; T_Fights &gt;= 27 | W_by_Sub &gt;= 15) Hopefully now you can understand the difference. How many athletes (observations) are left in Q5? 3.10.4 mutate() Moving on to mutate() now. Lets add a new column onto the table Example_1, that shows Reach but in meters rather than inches, and we’ll call it ReachM. We can make this column with mutate() by converting the inches value in the original Reach column into centimeters, by multiplying (*) the value by 2.54 and then dividing (/) the result by 100. Example_4 &lt;- Example_1 %&gt;% mutate(ReachM = (Reach*2.54)/100) Example_4 ## # A tibble: 199 × 7 ## ID Height Weight BMI Reach Stance ReachM ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 056c493bbd76a918 64 125 21.5 64 Orthodox 1.63 ## 2 b102c26727306ab6 65 125 20.8 67 Orthodox 1.70 ## 3 80eacd4da0617c57 64 125 21.5 65 Southpaw 1.65 ## 4 a4de54ea806fb525 64 125 21.5 63 Orthodox 1.60 ## 5 aa72b0f831d0bfe5 65 125 20.8 68 Orthodox 1.73 ## 6 92437c6775b3f7d1 66 125 20.2 66 Orthodox 1.68 ## 7 5aedf14771ca82d2 64 125 21.5 65 Southpaw 1.65 ## 8 a0f0004aadf10b71 65 125 20.8 67 Orthodox 1.70 ## 9 f53c1f4ceeed8c08 65 125 20.8 65 Orthodox 1.65 ## 10 ab2b4ff41d6ebe0f 66 125 20.2 65 Orthodox 1.65 ## # ℹ 189 more rows Question Time Your turn Take the table Example_1 and mutate a new column onto it called BMI_Alt, this time attempting to recalculate BMI using the Weight and Height variables. The calculation for BMI is; weight in kilograms devided by height in meters squared. Lets break down the steps, you will need to; - multiply Weight by 0.453 (to convert lbs to kgs) - divide that by… - Height multiplied 2.54 (to convert inches to cm), which you divide by 100 (to convert to m), which you then square Store the result in Q5. Hint - the ^ symbol is for calculating “to the power of” Solution # Sean&#39;s solution Q6 &lt;- Example_1 %&gt;% mutate(BMI_Alt = (Weight*0.453)/(((Height*2.54)/100)^2)) Don’t be worried if your new column is different by a few decimals (the original BMI was created with a slightly different calculation with different rounding). If they look approximately similar you have done it correctly. 3.10.5 group_by() and summarise() Now let’s brush up on group_by and summarise(). Here we will take the original table MMA_Data and group that data by WeightClass. Then we will create mean() summary stats for: Number of hits landed per minute (TLpM) and we’ll call that column MeanHit, Number of hits absorbed per minute (AbpM) and we’ll call that column MeanAbsorb, And average fight length (Time_Avg) and we’ll call that column MeanTime. Example_5 &lt;- MMA_Data %&gt;% group_by(WeightClass) %&gt;% summarise(MeanHit = mean(TLpM), MeanAbsorb = mean(AbpM), MeanTime = mean(Time_Avg)) # OR Example_5 &lt;- group_by(MMA_Data, WeightClass) %&gt;% # we could skip the first pipe if we wanted summarise(MeanHit = mean(TLpM), MeanAbsorb = mean(AbpM), MeanTime = mean(Time_Avg)) Question Time Which weightclass has the highest Hit average? Which weightclass has the lowest Absorbtion average? Which weightclass has the highest average time? Your turn In one continuous pipe chain: Take the original table MMA_Data and group that data by Stance and HeightClass AND THEN Create summary stats for success rate (Success), you should have columns called; MedSuccess that shows the median success rate MaxSuccess that shows the maximum success rate MinSuccess that shows the minimum success rate SDSuccess that shows the standard deviation of success rate The resulting table should be stored in Q6. Solution # Sean&#39;s solution Q6 &lt;- MMA_Data %&gt;% group_by(Stance, HeightClass) %&gt;% summarise(MedSuccess = median(Success), MaxSuccess = max(Success), MinSuccess = min(Success), SDSuccess = sd(Success)) ## `summarise()` has grouped output by &#39;Stance&#39;. You can override using the ## `.groups` argument. Which Stance/HeightClass combo has the highest median success rate? (enter your answers in the format Stance/HeightClass) What is the minimum success rate of tall athletes with an orthodox stance? What is the standard deviation in success rate for short athletes with a southpaw stance? (write your answer to 3 decimal places) 3.10.6 Bringing it all together Question Time Your turn In one continuous pipe chain: Take the original table MMA_Data, and select only ID, WeightClass, Stance, T_Wins, W_by_Decision, W_by_KO/TKO and W_by_Sub Filter out all the athletes with the “Southpaw” Stance Add on a new column called Perc_W_by_Dec that shows the percentage of total wins (T_Wins) that are accounted for by decisions (W_by_Decision) Group the data by WeightClass Create summary stats that show the mean of Perc_W_by_Dec Store the result in a variable called Q7. Solution # Sean&#39;s solution Q7 &lt;- MMA_Data %&gt;% select(ID, WeightClass, Stance, T_Wins, W_by_Decision:W_by_Sub) %&gt;% filter(Stance != &quot;Southpaw&quot;) %&gt;% mutate(Perc_W_by_Dec = (W_by_Decision/T_Wins)*100) %&gt;% group_by(WeightClass) %&gt;% summarise(AvgPercDec = mean(Perc_W_by_Dec)) Which weightclass has the lowest average percentage of wins by decision? "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
