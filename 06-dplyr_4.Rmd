# Tidy Data 3: Joins 

## Intended Learning Outcomes {-}

The whole purpose of the next two lecture is to tidy up dataframe and expose you to a bunch of useful functions that would make your daily life easier when dealing with your own data. By the end of today, you will know:

1. How to rearrange data from long format into to wide format and vice versa
2. How to combine and separate columns


## Pre-steps

Before we can start to focus on some other functions that might come in handy for data manipulation, we need to make sure to load `tidyverse` into the library. 

```{r L6, message=FALSE}
library(tidyverse)
```


## Two-Table Verbs

More often than not you will find yourself with data across multiple tables. In order to effectively combine multiple tables, `dplyr` provides a selection of **two-table verbs**. Today we will focus on two categories of two-table verbs - mutating join verbs and binding join verbs.



### Bringing in new data

First of all lets bring in some new data to look at these new functions.

#### What's the data

Source: Met Office National Climate Information Centre
https://www.metoffice.gov.uk/research/climate/maps-and-data/uk-and-regional-series

wos_seasonal_sun: Seasonal total duration of bright sunshine for Scotland W; Areal series, starting in 1919

wos_monthly_sun: Monthly and annual total duration of bright sunshine for Scotland W; Areal series, starting in 1919

wos_seasonal_rain: Seasonal total precipitation amount for Scotland W; Areal series, starting in 1862

wos_monthly_rain: Monthly and annual total precipitation amount for Scotland W; Areal series, starting in 1862

```{r}
wos_seasonal_sun <- read_csv("data/wos_seasonal_sun.csv")

wos_monthly_sun <- read_csv("data/wos_monthly_sun.csv")

wos_seasonal_rain <- read_csv("data/wos_seasonal_rain.csv")

wos_monthly_rain <- read_csv("data/wos_monthly_rain.csv")
```


###	Mutating Join Verbs

Mutating join verbs combine the variables (columns) of two tables so that matching rows are together. There are 4 different types of mutating joins, namely `inner_join()`, `left_join()`, `right_join()`, and `full_join()`.

Mutating joins have the following basic syntax:

<center> <img src="images/join.png"> </center>

To help you visualise what these joining functions are doing, we will use some simple diagrams, like the one below. Here `data1` (shown below in blue) represents our "left" dataframe (or table) and `data2` (shown below in green) represents our "right" dataframe.

<center> <img src="images/join_tables.png" height="200"> </center>

To make things nice and clear to see, lets simplify our data a litte.

```{r}
Summer_Rain <- wos_seasonal_rain %>% 
  select(year, sum)

Summer_Sun <- wos_seasonal_sun %>% 
  select(year, sum)

Summer_Rain
Summer_Sun
```

```{block, type="info"}
Now we have;
* rain data for the summer months from 1862 to 2015 (`Summer_Rain`)
* sunshine data for the summer months from 1919 to 2020 (`Summer_Sun`)
Notice they have data from some of the same years, but also have data from years unique to each table
```


#### inner_join()

`inner_join()` returns all rows from both tables for which the values in column specified in the `"by = "` statement overlap. 

<center> <img src="images/inner_join1.png"> </center>

Here we merge `Summer_Sun` and `Summer_Rain` with `inner_join()` specifying we want to "join by" the variable `year`. Becuase the remaining variable has the same name in both tables, R needs to distiguish them from each other, for that we use the `suffix = ` arguement, which allows us to specify what suffix to add to each column of the resulting table. If we do not spcify this, R will add a `.x` and `.y` suffix for us to the x (left) and y (right) table variables respectively.

```{r}
inner <- inner_join(Summer_Sun, Summer_Rain, by="year", suffix = c("_sun", "_rain"))
inner
```

Using an inner join returns only 97 (1919 to 2015) rows of observations because these are the only years in `year` that are present in both the Sun (1919 to 2020) and the Rain (1862 to 2015) data tables. However, we are still merging both tibbles together, meaning that all columns from `Summer_Sun` and `Summer_Rain` are kept (in our case `sum`, with a suffix added to each to tell them appart). In this example, the years 1862 to 1918, are dropped becuase they are not present in the Sun data, and the years 2016 to 2020 are dropped becuase they are not present in the Rain data.

```{block, type="funfact"}
If you don't specify which variable to "join by", and omit the by statement, the R will joing by all columns in common... 

Try it for yourself in the `Console` and see what happens
```


<span style="font-size: 22px; font-weight: bold; color: hsl(24, 100%, 50%);">Question Time</span>

How many rows (or observations) does `inner` have? `r fitb("97")` <br>
How many columns (or variables) does `inner` have? `r fitb("3")` <br>



#### left_join()

`left_join()` retains the complete first (left) table and adds values from the second (right) table that have matching values in the column specified in the `"by ="` statement. Rows in the left table with no match in the right table will have missing values (`NA`) in the new columns. 


<center> <img src="images/left_join1.png"> </center>

Let's try this `left_join()` function for our simple example of `Summer_Sun` and `Summer_Rain` in R.

```{r}
left <- left_join(Summer_Sun, Summer_Rain, by="year", suffix = c("_sun", "_rain"))
left
```

Here `Summer_Sun` is returned in full, and for every matching `year` in `Summer_Rain` the value is added. However, `Summer_Rain` does not have any value for the years 2016 to 2020, hence `NA` is added here to the column `sum_rain`.  

<span style="font-size: 22px; font-weight: bold; color: hsl(24, 100%, 50%);">Question Time</span>

How many rows (or observations) does `left` have? `r fitb("102")` <br>
How many columns (or variables) does `left` have? `r fitb("3")` <br>




#### right_join()

`right_join()` retains the complete second (right) table and adds values from the first (left) table that have matching values in the column specified in the by statement. Rows in the right table with no match in the left table will have missing values (`NA`) in the new columns.

<center> <img src="images/right_join1.png"> </center>

However, code-wise, you would still enter x as the first, and y as the second argument within `right_join()`.

```{r}
right <- right_join(Summer_Sun, Summer_Rain, by="year", suffix = c("_sun", "_rain"))
right
```
Here `Summer_Rain` is returned in full, and for every matching `year` in `Summer_Sun` the value is added, for any row of `Summer_Rain` that does not have a mating value in `Summer_Sun`, `NA` is added. Notice the order of the rows, though!!! All the years of `Summer_Sun` come first before the extra rows from `Summer_Rain` are added at the bottom. That is due to the order of how they are entered into the `right_join()` function. The "left" data (first table) is still prioritised in terms of ordering observations!

<span style="font-size: 22px; font-weight: bold; color: hsl(24, 100%, 50%);">Question Time</span>

How many rows (or observations) does `right` have? `r fitb("154")` <br>



#### full_join()

`full_join()` returns all rows and all columns from both dataframes. `NA` values fill unmatched rows. 

<center> <img src="images/full_join1.png"> </center>


```{r}
full <- full_join(Summer_Sun, Summer_Rain, by="year", suffix = c("_sun", "_rain"))
full
```

As you can see, all years from both tables are kept, and `NA` is used to fill the missing years (1862 to 1918 for `sum_sun`, and 2016 to 2020 for `sum_rain`). Again you can see the prioritization of the left (first) table in the arrangement of the years.


<span style="font-size: 22px; font-weight: bold; color: hsl(24, 100%, 50%);">Question Time</span>

How many rows (or observations) does `full` have? `r fitb("159")` <br>


### Mutating Join Summary

| join function | Description  |
|:----------|:---------------------------|
| inner_join() | Includes all rows that are PRESENT IN BOTH the left and the right table  |
| left_join() | Includes all rows from the left table (first data entered) |
| left_join() | Includes all rows from the right table (second data entered) |
|	full_join() | Includes all rows from both left and right tables |


<span style="font-size: 22px; font-weight: bold; color: hsl(24, 100%, 50%);">Question Time</span>

```{block, type="task"}
**Your turn**

Join together `wos_seasonal_rain` and `wos_seasonal_sun` so that we keep all the rows from the `wos_seasonal_sun` table, add a useful suffix so you can differentiate between columns with the same name. Store the result in `Q10`.
```

`r hide("Solution")`
```{r}
#Jaimie's solution
Q10 <- left_join(wos_seasonal_sun, wos_seasonal_rain, by = "year", suffix = c("_sun", "_rain"))
#OR 
Q10 <- right_join(wos_seasonal_rain, wos_seasonal_sun, by = "year", suffix = c("_rain", "_sun"))

Q10
```
`r unhide()`


###	Binding Join Verbs

In contrast to mutating join verbs, binding join verbs simply combine tables without any need for matching. Dplyr provides `bind_rows()` and `bind_cols()` for combining tables by row and column respectively. When row binding, missing columns are replaced by `NA` values. When column binding, if the tables do not match by appropriate dimensions, an error will result. 


#### bind_rows()

`bind_rows()` is ideal when you have more entries of the same kind of data, i.e. new observations of the same variables. (For example; you have a new batch of participants answering the same questionnaire; or you have new air pollution data from a different geographic region... same variables - different observations)

Lets split some data

```{r}
Sun_Season_1 <- wos_seasonal_sun %>%
  filter(year >= 1970)

Sun_Season_2 <- wos_seasonal_sun %>%
  filter(year < 1970)
```

Now we have 2 indetical tables for seasonal sunshine in the west of Scotland, but for different sets of years. All the same variables, but totally different observations.

We can easily join these together with `bind_rows` to create a complete history.
```{r}
Bind_1 <- bind_rows(Sun_Season_1, Sun_Season_2)
Bind_1
```
`bind_rows()` takes the second table `Sun_Season_2` and puts it *directly underneath* the first table `Sun_Season_1`. 


What happens if we attempt to bind tables with different dimensions
```{r}
Bind_2 <- bind_rows(Sun_Season_1, inner)
Bind_2
```
Notice that the `bind_rows()` does not "care" if it duplicates rows, here we have repeat years. Also `bind_rows()` does not "care" that there are columns that do not match between the tables, here `NA` is added fill the missing space. 

#### bind_cols()

`bind_cols()` is similar to our mutating join verbs in that it creates a new table by joining columns (or variables) together. However, note that `bind_cols()` does not perform any kind of row-wise matching when joining tables.

```{r}
Bind_3 <- bind_cols(wos_monthly_sun, wos_seasonal_sun)
```
`bind_cols()`takes `wos_seasonal_sun` and puts it *right next* to `wos_monthly_sun`. Since the column name `year` is in both tables they get called `year..1` and `year...15` after their respective column number to differentiate them.



What happens if we attempt to bind tables with different dimensions
```{r, error=TRUE}
Bind_4 <- bind_cols(Summer_Sun, Summer_Rain)
```
You simply get an error



```{block, type="funfact"}
By the way, you can merge as many data objects as you like with the binding functions, whereas in the join functions, you are limited to two. However, you could use a pipe to combine the merged dataframe with a third.

example 1: bind_rows(data1, data2, data3) <br>
example 2: full_join(data1, data2) %>% full_join(data3)
```


Just to further clarify the differences between `bind_cols()` and the mutating joing verbs, lets look at how they would deal with the same challenge

First lets create a new table for winter sun data, but lets arrange it by "win", so that rather than being in order of `year`, it is in order of most sunshine. This will have the same dimensions as the Summer_Sun table but a totally different order

```{r}
Winter_Sun <- wos_seasonal_sun %>% 
  select(year, win) %>%
  arrange(desc(win))
Winter_Sun
```

Now lets try joining Winter_Sun and Summer_Sun using the two different methods
```{r}
Comparison_1 <- bind_cols(Summer_Sun, Winter_Sun)
Comparison_2 <- left_join(Summer_Sun, Winter_Sun, "year")

Comparison_1
Comparison_2
```


```{block, type="info"}
Using bind_cols() simply "copy and pasted" the two tables together, the fact that the rows were in different orders did not matter. On the other hand, using left_join() meant that R compared the content of "year" and matched them up, ignoring the fact that Winter_Sun was in a different arrangement.
```


## Additional information

Garrick Aden-Buie created some amazing gganimation gif to illustrate how the joins work. Check it out! https://www.garrickadenbuie.com/project/tidyexplain/